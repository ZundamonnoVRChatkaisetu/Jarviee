"""
Action Execution Framework for Autonomous Action Engine.

This module implements the execution system for plans generated by the planning module.
It manages the execution flow of plan steps, handles dependencies, and monitors progress.
The executor can run actions in different execution modes (sequential, parallel, adaptive)
and responds to execution events and feedback.
"""

import asyncio
import logging
import time
import json
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Set, Tuple, Union, Callable
from enum import Enum, auto

from ....utils.event_bus import EventBus, Event
from ...knowledge.query_engine import QueryEngine
from ..planning.models import Plan, PlanStatus, PlanStep, ExecutionStrategy
from .models import ActionResult, ActionStatus, ExecutionOptions


class ExecutionMode(Enum):
    """Execution modes for the executor."""
    NORMAL = auto()  # Standard execution
    DRY_RUN = auto()  # Simulate execution without real actions
    DEBUG = auto()    # Detailed logging and step-by-step execution
    SAFE = auto()     # Extra validation and confirmation steps


class StepExecutionStatus(Enum):
    """Status of a step during execution."""
    PENDING = auto()       # Not yet ready for execution
    READY = auto()         # Ready to execute
    IN_PROGRESS = auto()   # Currently executing
    COMPLETED = auto()     # Successfully completed
    FAILED = auto()        # Failed to execute
    SKIPPED = auto()       # Skipped due to conditions or dependencies
    CANCELLED = auto()     # Cancelled by system or user


class ActionRegistry:
    """
    Registry for available action handlers.
    Maps action types to their handler functions.
    """
    
    def __init__(self):
        """Initialize the action registry."""
        self.handlers = {}
        self.logger = logging.getLogger(__name__)
    
    def register(self, action_type: str, handler: Callable) -> None:
        """
        Register a handler for an action type.
        
        Args:
            action_type: Type of action
            handler: Function that handles the action
        """
        self.logger.info(f"Registering handler for action type: {action_type}")
        self.handlers[action_type] = handler
    
    def get_handler(self, action_type: str) -> Optional[Callable]:
        """
        Get the handler for an action type.
        
        Args:
            action_type: Type of action
            
        Returns:
            Handler function if registered, None otherwise
        """
        handler = self.handlers.get(action_type)
        if not handler:
            self.logger.warning(f"No handler registered for action type: {action_type}")
        return handler
    
    def list_supported_actions(self) -> List[str]:
        """
        Get a list of supported action types.
        
        Returns:
            List of registered action types
        """
        return list(self.handlers.keys())


class ActionExecutor:
    """
    Component responsible for executing individual actions.
    Manages action dispatch, validation, and result processing.
    """
    
    def __init__(self, action_registry: ActionRegistry):
        """
        Initialize the action executor.
        
        Args:
            action_registry: Registry of action handlers
        """
        self.action_registry = action_registry
        self.logger = logging.getLogger(__name__)
    
    async def execute_action(self, 
                          step: PlanStep, 
                          context: Dict[str, Any], 
                          execution_mode: ExecutionMode = ExecutionMode.NORMAL) -> ActionResult:
        """
        Execute a single action step.
        
        Args:
            step: The step to execute
            context: Execution context with parameters and state
            execution_mode: Mode of execution
            
        Returns:
            Result of the action execution
        """
        start_time = time.time()
        
        # Log execution start
        self.logger.info(f"Executing step {step.step_id}: {step.description} ({step.action_type})")
        
        # Validate parameters and constraints
        validation_result = self._validate_step(step, context)
        if not validation_result["valid"]:
            self.logger.error(f"Step validation failed: {validation_result['reason']}")
            return ActionResult(
                status=ActionStatus.FAILED,
                step_id=step.step_id,
                execution_time=0,
                error=f"Validation failed: {validation_result['reason']}"
            )
        
        # Check if we're in dry run mode
        if execution_mode == ExecutionMode.DRY_RUN:
            self.logger.info(f"DRY RUN: Would execute {step.action_type} action")
            return ActionResult(
                status=ActionStatus.COMPLETED,
                step_id=step.step_id,
                execution_time=0,
                result={"message": "Dry run - action simulated"},
                is_simulated=True
            )
        
        # Get the appropriate handler
        handler = self.action_registry.get_handler(step.action_type)
        if not handler:
            return ActionResult(
                status=ActionStatus.FAILED,
                step_id=step.step_id,
                execution_time=time.time() - start_time,
                error=f"No handler available for action type: {step.action_type}"
            )
        
        # Handle debug mode
        if execution_mode == ExecutionMode.DEBUG:
            self.logger.debug(f"DEBUG MODE: Action details for {step.step_id}:")
            self.logger.debug(f"- Action Type: {step.action_type}")
            self.logger.debug(f"- Parameters: {json.dumps(step.parameters, indent=2)}")
            self.logger.debug(f"- Context: {json.dumps({k: str(v) for k, v in context.items()}, indent=2)}")
        
        # Execute the action
        try:
            # Combine step parameters with context
            execution_params = {
                "parameters": step.parameters,
                "context": context,
                "execution_mode": execution_mode
            }
            
            # Call the handler
            result = await handler(**execution_params)
            
            # Process the result
            execution_time = time.time() - start_time
            
            # Create action result
            if isinstance(result, dict) and "status" in result:
                # Handler returned a structured result
                action_result = ActionResult(
                    status=ActionStatus(result["status"]),
                    step_id=step.step_id,
                    execution_time=execution_time,
                    result=result.get("data"),
                    error=result.get("error")
                )
            else:
                # Handler returned a simple result
                action_result = ActionResult(
                    status=ActionStatus.COMPLETED,
                    step_id=step.step_id,
                    execution_time=execution_time,
                    result=result
                )
            
            # Log completion
            log_level = logging.DEBUG if execution_mode == ExecutionMode.DEBUG else logging.INFO
            self.logger.log(log_level, f"Step {step.step_id} completed in {execution_time:.2f}s with status {action_result.status.name}")
            
            return action_result
            
        except Exception as e:
            execution_time = time.time() - start_time
            self.logger.error(f"Error executing step {step.step_id}: {str(e)}")
            
            # Create failure result
            return ActionResult(
                status=ActionStatus.FAILED,
                step_id=step.step_id,
                execution_time=execution_time,
                error=str(e)
            )
    
    def _validate_step(self, step: PlanStep, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate a step before execution.
        
        Args:
            step: The step to validate
            context: Execution context
            
        Returns:
            Validation result with valid flag and optional reason
        """
        # Check that all required parameters are present
        handler = self.action_registry.get_handler(step.action_type)
        if not handler:
            return {"valid": False, "reason": f"No handler for action type: {step.action_type}"}
        
        # Validate constraints
        for constraint in step.constraints:
            # Evaluate constraint condition
            if constraint.constraint_type == "precondition":
                # Check if precondition is met in context
                if not self._evaluate_precondition(constraint.description, context):
                    return {"valid": False, "reason": f"Precondition not met: {constraint.description}"}
            
            # Check resource constraints
            elif constraint.constraint_type == "resource":
                if not self._check_resource_available(constraint.description, context):
                    return {"valid": False, "reason": f"Resource constraint not met: {constraint.description}"}
        
        return {"valid": True}
    
    def _evaluate_precondition(self, condition: str, context: Dict[str, Any]) -> bool:
        """
        Evaluate a precondition expression.
        
        Args:
            condition: Condition to evaluate
            context: Execution context
            
        Returns:
            True if condition is met, False otherwise
        """
        # This is a simplified implementation
        # In a real system, this would use more sophisticated condition evaluation
        
        # Check for simple key existence conditions
        if condition.startswith("has:"):
            key = condition[4:].strip()
            return key in context
        
        # Check for value comparison
        if "==" in condition:
            key, value = condition.split("==", 1)
            key = key.strip()
            value = value.strip()
            
            # Handle string values
            if value.startswith('"') and value.endswith('"'):
                value = value[1:-1]
            # Handle numeric values
            elif value.isdigit():
                value = int(value)
            elif value.lower() == "true":
                value = True
            elif value.lower() == "false":
                value = False
            
            return key in context and context[key] == value
        
        # Default to True if we can't evaluate
        return True
    
    def _check_resource_available(self, resource_desc: str, context: Dict[str, Any]) -> bool:
        """
        Check if a required resource is available.
        
        Args:
            resource_desc: Resource constraint description
            context: Execution context
            
        Returns:
            True if resource is available, False otherwise
        """
        # This is a simplified implementation
        # In a real system, this would use more sophisticated resource checking
        
        # Check if context has resource information
        if "available_resources" not in context:
            # Can't validate without resource information
            return True
        
        resources = context["available_resources"]
        
        # Parse resource requirement
        if ">" in resource_desc:
            # Quantity comparison
            resource_type, quantity = resource_desc.split(">", 1)
            resource_type = resource_type.strip()
            quantity = float(quantity.strip())
            
            return (resource_type in resources and 
                    isinstance(resources[resource_type], (int, float)) and 
                    resources[resource_type] > quantity)
        
        # Simple existence check
        resource_type = resource_desc.strip()
        return resource_type in resources
    

class PlanExecutor:
    """
    Main executor component for executing plans.
    Manages the execution flow, step dependencies, and plan status.
    """
    
    def __init__(self, 
               event_bus: EventBus, 
               action_executor: ActionExecutor,
               knowledge_engine: Optional[QueryEngine] = None,
               config: Dict[str, Any] = None):
        """
        Initialize the plan executor.
        
        Args:
            event_bus: System event bus for communication
            action_executor: Executor for individual actions
            knowledge_engine: Optional knowledge query engine
            config: Configuration parameters
        """
        self.event_bus = event_bus
        self.action_executor = action_executor
        self.knowledge_engine = knowledge_engine
        
        self.config = config or {
            "default_execution_timeout": 3600,  # 1 hour
            "max_parallel_actions": 5,
            "retry_failed_steps": True,
            "max_retries": 3,
            "backoff_factor": 1.5,  # For exponential backoff
            "enable_adaptive_execution": True,
            "monitor_resource_usage": True
        }
        
        # Execution state
        self.executions = {}  # plan_id -> execution state
        
        # Setup logging
        self.logger = logging.getLogger(__name__)
        
        # Register event handlers
        self._register_event_handlers()
    
    def _register_event_handlers(self):
        """Register handlers for execution-related events."""
        self.event_bus.subscribe("execution.start", self._handle_execution_start)
        self.event_bus.subscribe("execution.stop", self._handle_execution_stop)
        self.event_bus.subscribe("execution.pause", self._handle_execution_pause)
        self.event_bus.subscribe("execution.resume", self._handle_execution_resume)
        self.event_bus.subscribe("plan.updated", self._handle_plan_updated)
    
    async def execute_plan(self, 
                         plan_id: str, 
                         options: Optional[ExecutionOptions] = None,
                         context: Optional[Dict[str, Any]] = None) -> str:
        """
        Execute a plan.
        
        Args:
            plan_id: ID of the plan to execute
            options: Execution options
            context: Initial execution context
            
        Returns:
            Execution ID
        """
        # Get the plan from the event bus
        plan_event = Event(
            event_type="plan.get",
            source="executor",
            data={"plan_id": plan_id}
        )
        plan_response = await self.event_bus.request(plan_event)
        
        if not plan_response or "plan" not in plan_response.data:
            raise ValueError(f"Could not retrieve plan {plan_id}")
        
        plan = plan_response.data["plan"]
        
        # Create execution ID
        execution_id = f"exec_{plan_id}_{int(time.time())}"
        
        # Set up execution options
        options = options or ExecutionOptions()
        
        # Create execution context
        execution_context = context or {}
        execution_context.update({
            "execution_id": execution_id,
            "plan_id": plan_id,
            "start_time": datetime.now().isoformat(),
        })
        
        # Initialize execution state
        self.executions[execution_id] = {
            "plan_id": plan_id,
            "status": "initializing",
            "start_time": time.time(),
            "context": execution_context,
            "options": options,
            "steps": {},
            "completed_steps": set(),
            "failed_steps": set(),
            "in_progress_steps": set(),
            "pending_steps": set(plan.steps.keys()),
            "results": {},
            "task": None  # Will hold the execution task
        }
        
        # Initialize step statuses
        for step_id, step in plan.steps.items():
            self.executions[execution_id]["steps"][step_id] = {
                "status": StepExecutionStatus.PENDING,
                "attempts": 0,
                "start_time": None,
                "end_time": None,
                "result": None
            }
        
        # Update plan status
        await self._update_plan_status(plan_id, PlanStatus.IN_PROGRESS)
        
        # Publish execution started event
        self._publish_execution_event("execution.started", execution_id, {
            "plan_id": plan_id,
            "mode": options.mode.name if options.mode else "NORMAL"
        })
        
        # Start execution based on strategy
        if options.async_execution:
            # Start as a background task
            self.executions[execution_id]["task"] = asyncio.create_task(
                self._execution_task(execution_id, plan)
            )
            self.executions[execution_id]["status"] = "running"
            return execution_id
        else:
            # Run synchronously
            try:
                await self._execution_task(execution_id, plan)
                return execution_id
            except Exception as e:
                self.logger.error(f"Error in plan execution: {str(e)}")
                self.executions[execution_id]["status"] = "failed"
                await self._update_plan_status(plan_id, PlanStatus.FAILED)
                
                # Publish execution failed event
                self._publish_execution_event("execution.failed", execution_id, {
                    "plan_id": plan_id,
                    "error": str(e)
                })
                
                return execution_id
    
    async def _execution_task(self, execution_id: str, plan: Dict[str, Any]) -> None:
        """
        Main execution task for a plan.
        
        Args:
            execution_id: ID of the execution
            plan: The plan to execute
        """
        if execution_id not in self.executions:
            self.logger.error(f"Execution {execution_id} not found")
            return
            
        execution = self.executions[execution_id]
        plan_id = execution["plan_id"]
        
        try:
            self.logger.info(f"Starting execution task for plan {plan_id}")
            execution["status"] = "running"
            
            # Get execution strategy
            execution_strategy = ExecutionStrategy.SEQUENTIAL
            if "execution_config" in plan and "strategy" in plan["execution_config"]:
                strategy_str = plan["execution_config"]["strategy"]
                if strategy_str == "PARALLEL":
                    execution_strategy = ExecutionStrategy.PARALLEL
                elif strategy_str == "ADAPTIVE":
                    execution_strategy = ExecutionStrategy.ADAPTIVE
            
            # Execute based on strategy
            if execution_strategy == ExecutionStrategy.PARALLEL:
                await self._execute_parallel(execution_id, plan)
            elif execution_strategy == ExecutionStrategy.ADAPTIVE:
                await self._execute_adaptive(execution_id, plan)
            else:
                await self._execute_sequential(execution_id, plan)
            
            # Check final execution status
            if execution["status"] == "running":
                # Check if there were any failed steps
                if execution["failed_steps"]:
                    execution["status"] = "completed_with_failures"
                    await self._update_plan_status(plan_id, PlanStatus.COMPLETED_WITH_ISSUES)
                    
                    # Publish execution completed with issues event
                    self._publish_execution_event("execution.completed_with_issues", execution_id, {
                        "plan_id": plan_id,
                        "failed_steps": list(execution["failed_steps"])
                    })
                else:
                    execution["status"] = "completed"
                    await self._update_plan_status(plan_id, PlanStatus.COMPLETED)
                    
                    # Publish execution completed event
                    self._publish_execution_event("execution.completed", execution_id, {
                        "plan_id": plan_id,
                        "execution_time": time.time() - execution["start_time"]
                    })
            
        except asyncio.CancelledError:
            self.logger.info(f"Execution {execution_id} was cancelled")
            execution["status"] = "cancelled"
            await self._update_plan_status(plan_id, PlanStatus.CANCELLED)
            
            # Publish execution cancelled event
            self._publish_execution_event("execution.cancelled", execution_id, {
                "plan_id": plan_id
            })
            
        except Exception as e:
            self.logger.error(f"Error in execution task {execution_id}: {str(e)}")
            execution["status"] = "failed"
            await self._update_plan_status(plan_id, PlanStatus.FAILED)
            
            # Publish execution failed event
            self._publish_execution_event("execution.failed", execution_id, {
                "plan_id": plan_id,
                "error": str(e)
            })
    
    async def _execute_sequential(self, execution_id: str, plan: Dict[str, Any]) -> None:
        """
        Execute a plan sequentially.
        
        Args:
            execution_id: ID of the execution
            plan: The plan to execute
        """
        execution = self.executions[execution_id]
        options = execution["options"]
        context = execution["context"]
        
        # Get ordered steps
        ordered_steps = self._get_ordered_steps(plan)
        
        # Execute steps in order
        for step in ordered_steps:
            # Check if execution has been stopped or paused
            if execution["status"] != "running":
                break
                
            step_id = step["step_id"]
            
            # Execute the step
            result = await self._execute_step(execution_id, step, context, options)
            
            # Update context with step result
            if result.status == ActionStatus.COMPLETED:
                context[f"result_{step_id}"] = result.result
                execution["completed_steps"].add(step_id)
                execution["pending_steps"].remove(step_id)
            else:
                execution["failed_steps"].add(step_id)
                execution["pending_steps"].remove(step_id)
                
                # Check if we should stop on failure
                if options.stop_on_failure:
                    self.logger.info(f"Stopping execution {execution_id} due to step failure")
                    execution["status"] = "failed"
                    break
    
    async def _execute_parallel(self, execution_id: str, plan: Dict[str, Any]) -> None:
        """
        Execute a plan with parallel execution of independent steps.
        
        Args:
            execution_id: ID of the execution
            plan: The plan to execute
        """
        execution = self.executions[execution_id]
        options = execution["options"]
        context = execution["context"]
        
        # Get steps by levels (groups that can be executed in parallel)
        step_levels = self._get_step_levels(plan)
        
        # Execute steps level by level
        for level, steps in enumerate(step_levels):
            # Check if execution has been stopped or paused
            if execution["status"] != "running":
                break
                
            self.logger.info(f"Executing level {level} with {len(steps)} steps")
            
            # Prepare tasks for this level
            tasks = []
            for step in steps:
                step_id = step["step_id"]
                
                # Skip steps with failed dependencies
                dependency_failed = False
                for dep_id in step["dependencies"]:
                    if dep_id in execution["failed_steps"]:
                        dependency_failed = True
                        break
                
                if dependency_failed:
                    self.logger.info(f"Skipping step {step_id} due to failed dependencies")
                    execution["steps"][step_id]["status"] = StepExecutionStatus.SKIPPED
                    execution["failed_steps"].add(step_id)
                    execution["pending_steps"].remove(step_id)
                    continue
                
                # Create task for step execution
                task = self._execute_step(execution_id, step, context.copy(), options)
                tasks.append((step_id, task))
            
            # Execute tasks in parallel
            if tasks:
                # Split tasks into batches if needed
                max_parallel = min(options.max_parallel_steps or 5, 
                                  self.config["max_parallel_actions"])
                
                for i in range(0, len(tasks), max_parallel):
                    batch = tasks[i:i+max_parallel]
                    
                    # Execute batch
                    batch_results = await asyncio.gather(*(task for _, task in batch), 
                                                     return_exceptions=True)
                    
                    # Process results
                    for idx, result in enumerate(batch_results):
                        step_id = batch[idx][0]
                        
                        # Handle exceptions
                        if isinstance(result, Exception):
                            self.logger.error(f"Exception in step {step_id}: {str(result)}")
                            execution["steps"][step_id]["status"] = StepExecutionStatus.FAILED
                            execution["steps"][step_id]["result"] = ActionResult(
                                status=ActionStatus.FAILED,
                                step_id=step_id,
                                execution_time=0,
                                error=str(result)
                            )
                            execution["failed_steps"].add(step_id)
                            execution["pending_steps"].remove(step_id)
                            continue
                        
                        # Update context with step result
                        if result.status == ActionStatus.COMPLETED:
                            context[f"result_{step_id}"] = result.result
                            execution["completed_steps"].add(step_id)
                            execution["pending_steps"].remove(step_id)
                        else:
                            execution["failed_steps"].add(step_id)
                            execution["pending_steps"].remove(step_id)
            
            # Check if we should stop due to failures
            if options.stop_on_failure and execution["failed_steps"]:
                self.logger.info(f"Stopping execution {execution_id} due to step failures")
                execution["status"] = "failed"
                break
    
    async def _execute_adaptive(self, execution_id: str, plan: Dict[str, Any]) -> None:
        """
        Execute a plan with adaptive execution strategy.
        Combines aspects of sequential and parallel execution
        and adapts based on runtime conditions.
        
        Args:
            execution_id: ID of the execution
            plan: The plan to execute
        """
        execution = self.executions[execution_id]
        options = execution["options"]
        context = execution["context"]
        
        # Get dependency graph
        dependency_graph = self._build_dependency_graph(plan)
        
        # Track ready and completed steps
        ready_steps = self._get_initial_ready_steps(dependency_graph)
        completed_steps = set()
        
        # Execute until all steps are processed
        while ready_steps and execution["status"] == "running":
            # Select steps to execute in this batch
            batch_size = self._determine_adaptive_batch_size(execution_id)
            batch = self._select_batch(ready_steps, batch_size, plan)
            
            # Execute batch
            tasks = [(step_id, self._execute_step(
                execution_id, 
                plan["steps"][step_id], 
                context.copy(), 
                options
            )) for step_id in batch]
            
            # Remove from ready steps
            for step_id in batch:
                ready_steps.remove(step_id)
            
            # Execute batch and process results
            if tasks:
                batch_results = await asyncio.gather(*(task for _, task in tasks), 
                                                 return_exceptions=True)
                
                for idx, result in enumerate(batch_results):
                    step_id = tasks[idx][0]
                    
                    # Handle exceptions
                    if isinstance(result, Exception):
                        self.logger.error(f"Exception in step {step_id}: {str(result)}")
                        execution["steps"][step_id]["status"] = StepExecutionStatus.FAILED
                        execution["steps"][step_id]["result"] = ActionResult(
                            status=ActionStatus.FAILED,
                            step_id=step_id,
                            execution_time=0,
                            error=str(result)
                        )
                        execution["failed_steps"].add(step_id)
                        execution["pending_steps"].remove(step_id)
                    elif result.status == ActionStatus.COMPLETED:
                        # Update context with step result
                        context[f"result_{step_id}"] = result.result
                        execution["completed_steps"].add(step_id)
                        execution["pending_steps"].remove(step_id)
                        completed_steps.add(step_id)
                    else:
                        execution["failed_steps"].add(step_id)
                        execution["pending_steps"].remove(step_id)
            
            # Check if we should stop due to failures
            if options.stop_on_failure and execution["failed_steps"]:
                self.logger.info(f"Stopping execution {execution_id} due to step failures")
                execution["status"] = "failed"
                break
            
            # Update ready steps based on completed steps
            self._update_ready_steps(ready_steps, completed_steps, dependency_graph, execution["failed_steps"])
            
            # If no more ready steps but not all steps processed, we might have a dependency issue
            if not ready_steps and len(completed_steps) + len(execution["failed_steps"]) < len(plan["steps"]):
                remaining = set(plan["steps"].keys()) - completed_steps - execution["failed_steps"]
                self.logger.warning(f"No more ready steps but {len(remaining)} steps remain: {remaining}")
                
                # Check for dependency cycles or unreachable steps
                problematic_steps = self._identify_problematic_steps(remaining, dependency_graph, execution["failed_steps"])
                
                for step_id in problematic_steps:
                    self.logger.warning(f"Marking problematic step {step_id} as failed")
                    execution["steps"][step_id]["status"] = StepExecutionStatus.FAILED
                    execution["steps"][step_id]["result"] = ActionResult(
                        status=ActionStatus.FAILED,
                        step_id=step_id,
                        execution_time=0,
                        error="Step is unreachable due to dependency issues or cycles"
                    )
                    execution["failed_steps"].add(step_id)
                    execution["pending_steps"].remove(step_id)
    
    async def _execute_step(self, 
                          execution_id: str, 
                          step: Dict[str, Any],
                          context: Dict[str, Any],
                          options: ExecutionOptions) -> ActionResult:
        """
        Execute a single step and handle retry logic.
        
        Args:
            execution_id: ID of the execution
            step: The step to execute
            context: Execution context
            options: Execution options
            
        Returns:
            Result of the action execution
        """
        execution = self.executions[execution_id]
        step_id = step["step_id"]
        
        # Mark step as in progress
        execution["steps"][step_id]["status"] = StepExecutionStatus.IN_PROGRESS
        execution["steps"][step_id]["start_time"] = time.time()
        execution["in_progress_steps"].add(step_id)
        
        # Publish step started event
        self._publish_execution_event("execution.step_started", execution_id, {
            "step_id": step_id,
            "plan_id": execution["plan_id"]
        })
        
        # Create PlanStep object
        plan_step = self._dict_to_plan_step(step)
        
        # Initialize retry counter
        max_retries = (options.max_retries if options.max_retries is not None 
                      else self.config["max_retries"])
        retry_count = 0
        
        # Execute with retry logic
        while True:
            execution["steps"][step_id]["attempts"] += 1
            
            # Get execution mode
            mode = options.mode or ExecutionMode.NORMAL
            
            # Execute the action
            result = await self.action_executor.execute_action(plan_step, context, mode)
            
            # Check if we need to retry
            should_retry = (
                result.status == ActionStatus.FAILED and 
                options.retry_failed_steps and 
                retry_count < max_retries
            )
            
            if not should_retry:
                break
                
            # Increment retry counter
            retry_count += 1
            
            # Calculate backoff time
            backoff_time = options.backoff_base * (options.backoff_factor ** retry_count)
            
            self.logger.info(f"Retrying step {step_id} (attempt {retry_count + 1}/{max_retries}) "
                          f"after {backoff_time:.2f}s backoff")
            
            # Wait before retrying
            await asyncio.sleep(backoff_time)
        
        # Mark step as completed or failed
        execution["steps"][step_id]["end_time"] = time.time()
        execution["steps"][step_id]["result"] = result
        execution["in_progress_steps"].remove(step_id)
        
        if result.status == ActionStatus.COMPLETED:
            execution["steps"][step_id]["status"] = StepExecutionStatus.COMPLETED
            
            # Publish step completed event
            self._publish_execution_event("execution.step_completed", execution_id, {
                "step_id": step_id,
                "plan_id": execution["plan_id"],
                "execution_time": result.execution_time
            })
        else:
            execution["steps"][step_id]["status"] = StepExecutionStatus.FAILED
            
            # Publish step failed event
            self._publish_execution_event("execution.step_failed", execution_id, {
                "step_id": step_id,
                "plan_id": execution["plan_id"],
                "error": result.error,
                "attempts": execution["steps"][step_id]["attempts"]
            })
        
        # Store result
        execution["results"][step_id] = result
        
        return result
    
    def _dict_to_plan_step(self, step_dict: Dict[str, Any]) -> PlanStep:
        """
        Convert a step dictionary to a PlanStep object.
        
        Args:
            step_dict: Step dictionary
            
        Returns:
            PlanStep object
        """
        # Create basic step
        step = PlanStep(
            step_id=step_dict["step_id"],
            description=step_dict["description"],
            action_type=step_dict["action_type"],
            parameters=step_dict.get("parameters", {}),
            dependencies=step_dict.get("dependencies", [])
        )
        
        # Add additional properties if present
        if "constraints" in step_dict:
            step.constraints = step_dict["constraints"]
        
        if "resource_requirements" in step_dict:
            step.resource_requirements = step_dict["resource_requirements"]
        
        if "estimated_duration" in step_dict:
            step.estimated_duration = step_dict["estimated_duration"]
        
        if "importance" in step_dict:
            step.importance = step_dict["importance"]
        
        if "retry_strategy" in step_dict:
            step.retry_strategy = step_dict["retry_strategy"]
        
        return step
    
    def _get_ordered_steps(self, plan: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Get steps in dependency order.
        
        Args:
            plan: The plan
            
        Returns:
            List of steps in execution order
        """
        # Build dependency graph
        graph = self._build_dependency_graph(plan)
        
        # Get steps in topological order
        ordered_steps = []
        visited = set()
        temp_visited = set()
        
        def visit(step_id):
            if step_id in temp_visited:
                # Cycle detected
                self.logger.warning(f"Dependency cycle detected involving step {step_id}")
                return
            
            if step_id in visited:
                return
                
            temp_visited.add(step_id)
            
            # Visit dependencies first
            for dep_id in graph.get(step_id, {}).get("dependencies", []):
                visit(dep_id)
            
            temp_visited.remove(step_id)
            visited.add(step_id)
            ordered_steps.append(plan["steps"][step_id])
        
        # Visit all steps
        for step_id in plan["steps"]:
            if step_id not in visited:
                visit(step_id)
        
        return ordered_steps
    
    def _get_step_levels(self, plan: Dict[str, Any]) -> List[List[Dict[str, Any]]]:
        """
        Group steps into levels based on dependencies.
        Each level can be executed in parallel.
        
        Args:
            plan: The plan
            
        Returns:
            List of step groups (levels)
        """
        # Build dependency graph
        graph = self._build_dependency_graph(plan)
        
        # Initialize levels
        levels = []
        visited = set()
        
        # Find steps with no dependencies
        level0 = []
        for step_id, step in plan["steps"].items():
            if not step.get("dependencies", []):
                level0.append(step)
                visited.add(step_id)
        
        levels.append(level0)
        
        # Build subsequent levels
        while len(visited) < len(plan["steps"]):
            next_level = []
            
            for step_id, step in plan["steps"].items():
                if step_id in visited:
                    continue
                    
                # Check if all dependencies are visited
                deps = step.get("dependencies", [])
                if all(dep in visited for dep in deps):
                    next_level.append(step)
                    visited.add(step_id)
            
            if not next_level:
                # No more steps can be added - might have dependency issues
                break
                
            levels.append(next_level)
        
        return levels
    
    def _build_dependency_graph(self, plan: Dict[str, Any]) -> Dict[str, Dict[str, Any]]:
        """
        Build a dependency graph for a plan.
        
        Args:
            plan: The plan
            
        Returns:
            Dependency graph
        """
        graph = {}
        
        # Build forward dependencies
        for step_id, step in plan["steps"].items():
            graph[step_id] = {
                "dependencies": step.get("dependencies", []),
                "dependents": []
            }
        
        # Build reverse dependencies (dependents)
        for step_id, step in plan["steps"].items():
            for dep_id in step.get("dependencies", []):
                if dep_id in graph:
                    graph[dep_id]["dependents"].append(step_id)
        
        return graph
    
    def _get_initial_ready_steps(self, dependency_graph: Dict[str, Dict[str, Any]]) -> Set[str]:
        """
        Get the initial set of ready steps (no dependencies).
        
        Args:
            dependency_graph: The dependency graph
            
        Returns:
            Set of ready step IDs
        """
        ready = set()
        
        for step_id, data in dependency_graph.items():
            if not data["dependencies"]:
                ready.add(step_id)
        
        return ready
    
    def _update_ready_steps(self, 
                          ready_steps: Set[str], 
                          completed_steps: Set[str],
                          dependency_graph: Dict[str, Dict[str, Any]],
                          failed_steps: Set[str]) -> None:
        """
        Update the set of ready steps based on completed steps.
        
        Args:
            ready_steps: Set of ready steps (modified in place)
            completed_steps: Set of completed steps
            dependency_graph: The dependency graph
            failed_steps: Set of failed steps
        """
        # Check all completed steps for dependents
        for step_id in completed_steps:
            if step_id not in dependency_graph:
                continue
                
            # Check each dependent
            for dependent_id in dependency_graph[step_id]["dependents"]:
                if dependent_id in ready_steps or dependent_id in completed_steps or dependent_id in failed_steps:
                    continue
                    
                # Check if all dependencies are satisfied
                all_deps_satisfied = True
                for dep_id in dependency_graph[dependent_id]["dependencies"]:
                    if dep_id not in completed_steps:
                        all_deps_satisfied = False
                        break
                
                # If all dependencies are satisfied, add to ready steps
                if all_deps_satisfied:
                    ready_steps.add(dependent_id)
    
    def _determine_adaptive_batch_size(self, execution_id: str) -> int:
        """
        Determine the optimal batch size for adaptive execution.
        Takes into account current system load and past performance.
        
        Args:
            execution_id: ID of the execution
            
        Returns:
            Optimal batch size
        """
        execution = self.executions[execution_id]
        options = execution["options"]
        
        # Get maximum parallel steps from options or config
        max_parallel = (options.max_parallel_steps if options.max_parallel_steps is not None 
                       else self.config["max_parallel_actions"])
        
        # This is a simplified implementation
        # In a real system, this would use more sophisticated logic
        
        # Adjust based on system load (simplified)
        system_load = 0.5  # Mock value between 0-1
        
        if system_load > 0.8:
            # High load - reduce batch size
            adjusted_size = max(1, int(max_parallel * 0.5))
        elif system_load > 0.5:
            # Medium load
            adjusted_size = max(1, int(max_parallel * 0.75))
        else:
            # Low load - use full capacity
            adjusted_size = max_parallel
        
        return adjusted_size
    
    def _select_batch(self, 
                     ready_steps: Set[str], 
                     batch_size: int,
                     plan: Dict[str, Any]) -> List[str]:
        """
        Select a batch of steps for execution.
        Prioritizes steps based on importance and dependencies.
        
        Args:
            ready_steps: Set of ready step IDs
            batch_size: Maximum batch size
            plan: The plan
            
        Returns:
            List of selected step IDs
        """
        if batch_size >= len(ready_steps):
            return list(ready_steps)
        
        # Score steps based on importance and dependencies
        scored_steps = []
        for step_id in ready_steps:
            step = plan["steps"].get(step_id)
            if not step:
                continue
                
            # Calculate score
            importance = step.get("importance", 50)
            dependency_count = len(step.get("dependencies", []))
            dependent_count = sum(1 for s in plan["steps"].values() 
                                if step_id in s.get("dependencies", []))
            
            # Higher score for more important steps and steps with more dependents
            score = importance + (dependent_count * 10)
            
            scored_steps.append((step_id, score))
        
        # Sort by score (descending)
        scored_steps.sort(key=lambda x: x[1], reverse=True)
        
        # Select top steps
        return [step_id for step_id, _ in scored_steps[:batch_size]]
    
    def _identify_problematic_steps(self, 
                                   remaining_steps: Set[str], 
                                   dependency_graph: Dict[str, Dict[str, Any]],
                                   failed_steps: Set[str]) -> Set[str]:
        """
        Identify steps that can't be executed due to dependency issues.
        
        Args:
            remaining_steps: Set of remaining step IDs
            dependency_graph: The dependency graph
            failed_steps: Set of failed step IDs
            
        Returns:
            Set of problematic step IDs
        """
        problematic = set()
        
        for step_id in remaining_steps:
            # Check if step depends on failed steps
            dependencies = dependency_graph.get(step_id, {}).get("dependencies", [])
            for dep_id in dependencies:
                if dep_id in failed_steps:
                    problematic.add(step_id)
                    break
        
        # If we didn't identify all remaining steps as problematic,
        # some might be part of dependency cycles
        if len(problematic) < len(remaining_steps):
            # Identify cycles (simplified approach)
            for step_id in remaining_steps - problematic:
                visited = set()
                path = []
                
                def check_cycle(current_id):
                    if current_id in path:
                        return True
                    if current_id in visited:
                        return False
                        
                    visited.add(current_id)
                    path.append(current_id)
                    
                    for dep_id in dependency_graph.get(current_id, {}).get("dependencies", []):
                        if check_cycle(dep_id):
                            return True
                            
                    path.pop()
                    return False
                
                if check_cycle(step_id):
                    problematic.add(step_id)
        
        return problematic
    
    async def stop_execution(self, execution_id: str, reason: Optional[str] = None) -> bool:
        """
        Stop an execution.
        
        Args:
            execution_id: ID of the execution to stop
            reason: Optional reason for stopping
            
        Returns:
            True if execution was stopped
        """
        if execution_id not in self.executions:
            self.logger.error(f"Execution {execution_id} not found")
            return False
            
        execution = self.executions[execution_id]
        
        # If execution is already stopped, do nothing
        if execution["status"] not in ("running", "paused"):
            return True
            
        # Stop the execution
        execution["status"] = "stopping"
        
        # Cancel the task if running asynchronously
        if execution["task"] and not execution["task"].done():
            execution["task"].cancel()
            try:
                await execution["task"]
            except asyncio.CancelledError:
                pass
        
        # Mark execution as stopped
        execution["status"] = "stopped"
        
        # Update plan status
        plan_id = execution["plan_id"]
        await self._update_plan_status(plan_id, PlanStatus.CANCELLED)
        
        # Publish execution stopped event
        self._publish_execution_event("execution.stopped", execution_id, {
            "plan_id": plan_id,
            "reason": reason or "Manually stopped"
        })
        
        return True
    
    async def pause_execution(self, execution_id: str) -> bool:
        """
        Pause an execution.
        
        Args:
            execution_id: ID of the execution to pause
            
        Returns:
            True if execution was paused
        """
        if execution_id not in self.executions:
            self.logger.error(f"Execution {execution_id} not found")
            return False
            
        execution = self.executions[execution_id]
        
        # If execution is not running, can't pause
        if execution["status"] != "running":
            return False
            
        # Pause the execution
        execution["status"] = "paused"
        
        # Publish execution paused event
        self._publish_execution_event("execution.paused", execution_id, {
            "plan_id": execution["plan_id"]
        })
        
        return True
    
    async def resume_execution(self, execution_id: str) -> bool:
        """
        Resume a paused execution.
        
        Args:
            execution_id: ID of the execution to resume
            
        Returns:
            True if execution was resumed
        """
        if execution_id not in self.executions:
            self.logger.error(f"Execution {execution_id} not found")
            return False
            
        execution = self.executions[execution_id]
        
        # If execution is not paused, can't resume
        if execution["status"] != "paused":
            return False
            
        # Resume the execution
        execution["status"] = "running"
        
        # Publish execution resumed event
        self._publish_execution_event("execution.resumed", execution_id, {
            "plan_id": execution["plan_id"]
        })
        
        # If execution was async, restart the task
        if "task" in execution and execution["task"] is None:
            # Get the plan
            plan_event = Event(
                event_type="plan.get",
                source="executor",
                data={"plan_id": execution["plan_id"]}
            )
            plan_response = await self.event_bus.request(plan_event)
            
            if plan_response and "plan" in plan_response.data:
                plan = plan_response.data["plan"]
                execution["task"] = asyncio.create_task(self._execution_task(execution_id, plan))
        
        return True
    
    def get_execution_status(self, execution_id: str) -> Optional[Dict[str, Any]]:
        """
        Get the status of an execution.
        
        Args:
            execution_id: ID of the execution
            
        Returns:
            Execution status information, or None if not found
        """
        if execution_id not in self.executions:
            return None
            
        execution = self.executions[execution_id]
        
        # Create status report
        status = {
            "execution_id": execution_id,
            "plan_id": execution["plan_id"],
            "status": execution["status"],
            "start_time": execution["start_time"],
            "elapsed_time": time.time() - execution["start_time"],
            "completed_steps": len(execution["completed_steps"]),
            "failed_steps": len(execution["failed_steps"]),
            "in_progress_steps": len(execution["in_progress_steps"]),
            "pending_steps": len(execution["pending_steps"]),
            "total_steps": len(execution["steps"]),
            "progress": len(execution["completed_steps"]) / len(execution["steps"]) if execution["steps"] else 0
        }
        
        return status
    
    def get_step_status(self, execution_id: str, step_id: str) -> Optional[Dict[str, Any]]:
        """
        Get the status of a specific step.
        
        Args:
            execution_id: ID of the execution
            step_id: ID of the step
            
        Returns:
            Step status information, or None if not found
        """
        if execution_id not in self.executions:
            return None
            
        execution = self.executions[execution_id]
        
        if step_id not in execution["steps"]:
            return None
            
        step_status = execution["steps"][step_id]
        
        # Create status report
        status = {
            "step_id": step_id,
            "status": step_status["status"].name,
            "attempts": step_status["attempts"],
            "start_time": step_status["start_time"],
            "end_time": step_status["end_time"],
            "duration": (step_status["end_time"] - step_status["start_time"]) 
                       if step_status["end_time"] and step_status["start_time"] else None
        }
        
        # Add result if available
        if step_status["result"]:
            status["result_status"] = step_status["result"].status.name
            
            if step_status["result"].error:
                status["error"] = step_status["result"].error
                
            if step_status["result"].result:
                # For large results, include a summary
                result = step_status["result"].result
                if isinstance(result, dict) and len(result) > 10:
                    status["result_summary"] = f"Dictionary with {len(result)} keys"
                elif isinstance(result, list) and len(result) > 10:
                    status["result_summary"] = f"List with {len(result)} items"
                else:
                    status["result"] = result
        
        return status
    
    async def _update_plan_status(self, plan_id: str, status: PlanStatus) -> None:
        """
        Update a plan's status via the event bus.
        
        Args:
            plan_id: ID of the plan
            status: New status
        """
        # Create update event
        update_event = Event(
            event_type="plan.update",
            source="executor",
            data={
                "plan_id": plan_id,
                "status": status.name
            }
        )
        
        # Publish event
        await self.event_bus.publish(update_event)
    
    def _publish_execution_event(self, event_type: str, execution_id: str, 
                               additional_data: Optional[Dict[str, Any]] = None) -> None:
        """
        Publish an execution-related event to the event bus.
        
        Args:
            event_type: Type of event
            execution_id: ID of the execution
            additional_data: Additional event data
        """
        # Prepare event data
        event_data = {
            "execution_id": execution_id,
        }
        
        # Add additional data if provided
        if additional_data:
            event_data.update(additional_data)
        
        # Create and publish the event
        event = Event(
            event_type=event_type,
            source="executor",
            data=event_data
        )
        
        self.event_bus.publish(event)
    
    def _handle_execution_start(self, event: Event) -> None:
        """
        Handle an execution.start event.
        
        Args:
            event: The event
        """
        data = event.data
        plan_id = data.get("plan_id")
        
        if not plan_id:
            self.logger.error("execution.start event missing plan_id")
            return
            
        options_data = data.get("options", {})
        context = data.get("context", {})
        
        # Create options
        options = ExecutionOptions()
        for key, value in options_data.items():
            if hasattr(options, key):
                setattr(options, key, value)
        
        # Start execution asynchronously
        asyncio.create_task(self.execute_plan(
            plan_id=plan_id,
            options=options,
            context=context
        ))
    
    def _handle_execution_stop(self, event: Event) -> None:
        """
        Handle an execution.stop event.
        
        Args:
            event: The event
        """
        data = event.data
        execution_id = data.get("execution_id")
        
        if not execution_id:
            self.logger.error("execution.stop event missing execution_id")
            return
            
        # Stop execution asynchronously
        asyncio.create_task(self.stop_execution(
            execution_id=execution_id,
            reason=data.get("reason")
        ))
    
    def _handle_execution_pause(self, event: Event) -> None:
        """
        Handle an execution.pause event.
        
        Args:
            event: The event
        """
        data = event.data
        execution_id = data.get("execution_id")
        
        if not execution_id:
            self.logger.error("execution.pause event missing execution_id")
            return
            
        # Pause execution asynchronously
        asyncio.create_task(self.pause_execution(execution_id))
    
    def _handle_execution_resume(self, event: Event) -> None:
        """
        Handle an execution.resume event.
        
        Args:
            event: The event
        """
        data = event.data
        execution_id = data.get("execution_id")
        
        if not execution_id:
            self.logger.error("execution.resume event missing execution_id")
            return
            
        # Resume execution asynchronously
        asyncio.create_task(self.resume_execution(execution_id))
    
    def _handle_plan_updated(self, event: Event) -> None:
        """
        Handle a plan.updated event.
        
        Args:
            event: The event
        """
        # Currently no specific handling required,
        # but could be extended to handle plan updates during execution
        pass
